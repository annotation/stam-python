from __future__ import annotations

from typing import Iterator, List, Optional, Tuple, Type, TypeAlias, Union

class AnnotationStore:
    """
    An Annotation Store is an unordered collection of annotations, resources and
    annotation data sets. It can be seen as the *root* of the *graph model* and the glue
    that holds everything together. It is the entry point for any stam model.
    """
    def __init__(self, id=None,file=None, string=None,config=None) -> None:
        """
        Instantiates a new annotationstore.
        
        Parameters
        ----------------
        id: Optional[str], default: None
            The public ID for a *new* store
        file: Optional[str], default: None
            The STAM JSON or STAM CSV file to load
        string: Optional[str], default: None
            STAM JSON as a string
        config: Optional[dict]
            A python dictionary containing configuration parameters
        
        At least one of `id`, `file` or `string` must be specified.
        """

    def id(self) -> Optional[str]:
        """Returns the public identifier (by value, aka a copy)"""

    def to_file(self, filename: str) -> Optional[str]:
        """Saves the annotation store to file. Use either .json or .csv as extension."""

    def save(self) -> None:
        """Saves the annotation store to the same file it was loaded from or last saved to."""

    def to_json_string(self) -> str:
        """Returns the annotation store as one big STAM JSON string"""

    def annotationset(self, id: str) -> AnnotationDataSet:
        """Basic retrieval method that returns an :class:`AnnotationDataSet` by ID"""

    def annotation(self, id: str) -> Annotation:
        """Basic retrieval method that returns an :class:`Annotation` by ID"""

    def resource(self, id: str) -> TextResource:
        """Basic retrieval method that returns a :class:`TextResource` by ID"""

    def add_resource(self, filename: Optional[str], text: Optional[str], id: Optional[str]) -> TextResource:
        """Create a new :class:`TextResource` and add it to the store. Returns the added instance."""

    def add_anotationset(self, id: str) -> AnnotationDataSet:
        """Create a new :class:`AnnotationDataSet` and add it to the store. Returns the added instance."""

    def set_filename(self, filename: str) -> None:
        """Set the filename for the annotationstore, the format is derived from the extension, can be `.json` or `csv`"""
    
    def annotate(self, target: Selector, data: Union[dict,List[dict],AnnotationData,List[AnnotationData]], id: Optional[str]) -> Annotation:
        """Adds a new annotation. Returns the :obj:`Annotation` instance that was just created.
        
        Parameters
        -------------
            
        target: :class:`Selector`
            A target selector that determines the object of annotation
        data: Union[dict,List[dict],AnnotationData,List[AnnotationData]]
            A dictionary or list of dictionaries with data to set. The dictionary
            may have fields: `id`,`key`,`set`, and `value`.
            Alternatively, you can pass an existing`AnnotationData` instance.
        id: Optional[str]
            The public ID for the annotation. If unset, one may be autogenerated.
        """

    def annotations(self) -> Iterator[Annotation]:
        """Returns an iterator over all annotations (:class:`Annotation`) in this store"""

    def annotationsets(self) -> Iterator[AnnotationDataSet]:
        """Returns an iterator over all annotation data sets (:class:`AnnotationDataSet`) in this store"""

    def resources(self) -> Iterator[TextResource]:
        """Returns an iterator over all text resources (:class:`TextResource`) in this store"""

    def annotations_len(self) -> int:
        """Returns the number of annotations in the store (not substracting deletions)"""

    def annotationsets_len(self) -> int:
        """Returns the number of annotation data sets in the store (not substracting deletions)"""

    def resources_len(self) -> int:
        """Returns the number of text resources in the store (not substracting deletions)"""

    def select(self, selector: Selector) -> Union[TextResource,Annotation,AnnotationDataSet,TextSelection, List[TextResource,Annotation,AnnotationDataSet,TextSelection]]:
        """
        Applies a selector to the annotation store and returns the target(s)
        May return a multitude of types depending on the selector, returns
        a list if multiple targets were found (internally consumes an iterator).
        """

class Annotation:
    """
    `Annotation` represents a particular *instance of annotation* and is the central
    concept of the model. They can be considered the primary nodes of the graph model. The
    instance of annotation is strictly decoupled from the *data* or key/value of the
    annotation (:class:`AnnotationData`). After all, multiple instances can be annotated
    with the same label (multiple annotations may share the same annotation data).
    Moreover, an `Annotation` can have multiple annotation data associated.
    The result is that multiple annotations with the exact same content require less storage
    space, and searching and indexing is facilitated.  
   
    This structure is not instantiated directly, only returned. Use :meth:`AnnotationStore.annotate()` to instantiate a new Annotation.
    """

    def id(self) -> Optional[str]:
        """Returns the public ID (by value, aka a copy)
        Don't use this for extensive ID comparisons, use :meth:`has_id` instead as it is more performant (no copy)."""

    def has_id(self, id: str) -> Optional[str]:
        """Tests the ID"""

    def __iter__(self) -> Iterator[AnnotationData]:
        """Returns a iterator over all data in this annotation"""

    def selector(self) -> Selector:
        """Returns a selector pointing to this annotation"""

    def text(self) -> List[str]:
        """Returns the text of the annotation.
        Note that this will always return a list (even it if only contains a single element),
        as an annotation may reference multiple texts.
       
        If you are sure an annotation only reference a single contingent text slice or are okay with slices being concatenated, then you can use the `str()` function instead."""

    def __str__(self) -> str:
        """
        Returns the text of the annotation.
        If the annotation references multiple text slices, they will be concatenated with a space as a delimiter,
        but note that in reality the different parts may be non-contingent!
       
        Use `text()` instead to retrieve a list of texts
        """

    def textselections(self) -> List[TextSelection]:
        """
        Returns a list of all textselections (:class:`TextSelection`) referenced by the annotation (i.e. via a *TextSelector*).
        Note that this will always return a list (even it if only contains a single element),
        as an annotation may reference multiple text selections.
        """

    def annotations(self, recursive= False, limit: Optional[int] = None) -> List[Annotation]:
        """Returns a list of annotations (:class:`Annotation`) this annotation refers to (i.e. using an *AnnotationSelector*)

        Parameters
        ------------

        recursive: bool
            Follow other Annotation Selectors when encounted
        limit: Optional[int] = None
            The maximum number of results to return (default: unlimited)
        """

    def annotations_reverse(self,  limit: Optional[int] = None) -> List[Annotation]:
        """Returns a list of annotations (:class:`Annotation`) that are referring to this annotation (i.e. others using an AnnotationSelector)

        Parameters
        ------------

        limit: Optional[int] = None
            The maximum number of results to return (default: unlimited)
        """

    def resources(self, limit: Optional[int] = None) -> List[TextResource]:
        """Returns a list of resources (:class:`TextResource`) this annotation refers to

        Parameters
        ------------

        limit: Optional[int] = None
            The maximum number of results to return (default: unlimited)
        """

    def annotationsets(self, limit: Optional[int] = None) -> List[AnnotationDataSet]:
        """Returns a list of annotation data sets (:class:`AnnotationDataSet`) this annotation refers to. This only returns the ones
        referred to via a *DataSetSelector*, i.e. as metadata.

        Parameters
        ------------

        limit: Optional[int] = None
            The maximum number of results to return (default: unlimited)
        """

    def target(self) -> Selector:
        """Returns the target selector for this annotation"""

    def data(self, limit: Optional[int] = None) -> List[AnnotationData]:
        """Returns a list of annotation data instances this annotation refers to."""

    def find_textselections(operator: TextSelectionOperator, limit: Optional[int] = None) -> List[TextSelection]:
        """
        Applies a :class:`TextSelectionOperator` to find all other
        text selections who are in a specific relation with the ones from the current annotation. 
        Returns all matching :class:`TextSelection` instances in a list.
       
        If you are interested in the annotations associated with the found text selections, then
        use :meth:`find_annotations` instead.

        Parameters
        ------------

        operator: TextSelectionOperator
            The operator to apply when comparing text selections
        limit: Optional[int] = None
            The maximum number of results to return (default: unlimited)
        """

    def find_annotations(operator: TextSelectionOperator, limit: Optional[int] = None) -> List[Annotation]:
        """
        Applies a :class:`TextSelectionOperator` to find all other annotations whose text selections
        are in a specific relation with the ones from the current annotation. 
        Returns all matching :class:`Annotation` instances in a list.
       
        If you are interested in the annotations associated with the found text selections, then
        use :meth:`find_annotations` instead.

        Parameters
        ------------

        operator: TextSelectionOperator
            The operator to apply when comparing the underlying text selections
        limit: Optional[int] = None
            The maximum number of results to return (default: unlimited)
        """

class AnnotationDataSet:
    """
    An `AnnotationDataSet` stores the keys (:class:`DataKey`) and values
    :class:`AnnotationData` (which in turn encapsulates :class:`DataValue`) that are used by annotations.

    It effectively defines a certain vocabulary, i.e. key/value pairs.
    The `AnnotationDataSet` does not store the :class:`Annotation` instances, those are in
    the :class:`AnnotationStore`. The datasets themselves are also held by the `AnnotationStore`.

    Use :meth:`AnnotationStore.add_annotationset()` to instantiate a new AnnotationDataSet, it can not be constructed directly.
    """

    def id(self) -> Optional[str]:
        """Returns the public ID (by value, aka a copy)
        Don't use this for extensive ID comparisons, use :meth:`has_id` instead as it is more performant (no copy)."""

    def has_id(self, id: str) -> Optional[str]:
        """Tests the ID"""

    def key(self, key: str) -> DataKey:
        """Basic retrieval method to obtain a key from a dataset"""

    def add_key(self, key: str) -> DataKey:
        """Create a new :class:`DataKey` and adds it to the dataset. Returns the added key."""

    def keys_len(self) -> int:
        """Returns the number of keys in the set"""

    def data_len(self) -> int:
        """Returns the number of annotation data instances in the set"""

    def add_data(self, key: str) -> AnnotationData:
        """Create a new :class:`AnnotationData` instances and add it to the dataset. Returns the added data."""

    def annotationdata(self, id: str) -> AnnotationData:
        """Basic retrieval method to obtain annotationdata from a dataset, by ID"""

    def keys(self) -> Iterator[DataKey]:
        """Returns an iterator over all :class:`DataKey` instances in the dataset"""

    def __iter__(self) -> Iterator[AnnotationData]:
        """Returns an iterator over all :class:`AnnotationData` in the dataset"""

    def selector(self) -> Selector:
        """Returns a selector pointing to this annotation dataset (via a *DataSetSelector*)"""

    def find_data(self, key: str, value: Union[DataValue,str,int,bool,float,List]) -> Optional[AnnotationData]:
        """
        Find annotation data by key and value.
        Returns an :class:`AnnotationData` instance if found, `None` otherwise
        """

class DataKey:
    """
    The DataKey class defines a vocabulary field, it
    belongs to a certain :class:`AnnotationDataSet`. A :class:`AnnotationData` instance
    in turn makes reference to a DataKey and assigns it a value.
    """

    def id(self) -> Optional[str]:
        """Returns the public ID (by value, aka a copy)
        Don't use this for extensive ID comparisons, use :meth:`has_id` instead as it is more performant (no copy)."""

    def has_id(self, id: str) -> Optional[str]:
        """Tests the ID"""

    def annotationset(self) -> AnnotationDataSet:
        """Returns the :class:`AnnotationDataSet` this key is part of"""

    def annotationdata(self) -> List[AnnotationData]:
        """
        Returns a list of :class:`AnnotationData` instances that use this key.
        """

    def find_data(self, value: Union[DataValue,str,int,bool,float,List]) -> Optional[AnnotationData]:
        """
        Find annotation data for the current key by value.
        Returns an :class:`AnnotationData` instance if found, `None` otherwise
        """

class DataValue:
    """Encapsulates a value and its type. Held by :class:`AnnotationData`. This type is not a reference but holds the actual value."""


    def get(self) -> Union[str,bool,int,float,List]:
        """Get the actual value"""

    def __init__(self, value: Union[str,bool,int,float,List]) -> None:
        """Instantiate a new DataValue from a Python type. You usually don't need to do this explicitly"""

    def __str__(self) -> str:
        """Get the actual value as as string"""

class AnnotationData:
    """
    AnnotationData holds the actual content of an annotation; a key/value pair. (the
    term *feature* is regularly seen for this in certain annotation paradigms).
    Annotation Data is deliberately decoupled from the actual :class:`Annotation`
    instances so multiple annotation instances can point to the same content
    without causing any overhead in storage. Moreover, it facilitates indexing and
    searching. The annotation data is part of an :class:`AnnotationDataSet`, which
    effectively defines a certain user-defined vocabulary.
   
    Once instantiated, instances of this type are, by design, largely immutable.
    The key and value can not be changed. Create a new AnnotationData and new Annotation for edits.
    This class is not instantiated directly.
    """

    def id(self) -> Optional[str]:
        """Returns the public ID (by value, aka a copy)
        Don't use this for extensive ID comparisons, use :meth:`has_id` instead as it is more performant (no copy)."""

    def has_id(self, id: str) -> Optional[str]:
        """Tests the ID"""

    def key(self) -> DataKey:
        """Basic retrieval method to obtain the key"""

    def value(self) -> DataValue:
        """Basic retrieval method to obtain the value"""

    def test_value(self, reference: DataValue) -> bool:
        """
        Tests whether the value equals another
        This is more efficient than calling :meth:`value`] and doing the comparison yourself.
        """

    def annotationset(self) -> AnnotationDataSet:
        """Returns the :class:`AnnotationDataSet` this data is part of"""

    def annotations(self, limit: Optional[int] = None) -> List[Annotation]:
        """Returns a list of annotations (:class:`Annotation`) that use this data.

        Parameters
        ------------

        limit: Optional[int] = None
            The maximum number of results to return (default: unlimited)
        """






